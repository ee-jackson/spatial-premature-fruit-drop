---
title: "testing for spatial autocorrelation"
author: "Eleanor Jackson"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  html_document:
    theme: lumen
    highlight: pygments
---

```{r, warning=FALSE, message=FALSE}
rm(list = ls())

library("tidyverse"); theme_set(theme_bw(base_size=10))
library("knitr")
library("spdep")
library("sf")
library("gstat")
load("../data/clean/trapConnect2.RData")

# take a subset of one year and one species to play with
# turn X and Y coordinates into a geometry
dplyr::filter(trapConnect, 
		(sp == "tri2tu" & year == 2015)) %>%
	sf::st_as_sf(coords = c("X", "Y")) -> dat
```
## Correlogram

A correlogram is probably the simplest way to look at spatial autocorrelation. The plot shows the correlation coefficient for the series lagged (in distance) by one delay at a time. e.g. at lag one you're looking at the correlation between a point and it's nearest neighbour. At lag two you're looking at the correlation between a point and it's second nearest neighbour.

Values close to 1 indicate clustering while values close to -1 indicate dispersion. A random arrangement would give a value that is close to 0.

```{r, warning=FALSE}

# detect nearest neigbours within a 100m radius
nn  <-  dnearneigh(dat, 0, 100, row.names = dat$trap) 

plot(
	spdep::sp.correlogram(neighbours = nn, var = dat$proportion_abscised, 
		order = 10, method = "corr", zero.policy = TRUE, style="W")
)

```

## Moran's I

We can look at the correlogram in combination with Moran's I, which is a global indicator of spatial autocorrelation for the dataset.

```{r, warning=FALSE}
plot(
	spdep::sp.correlogram(neighbours = nn, var = dat$proportion_abscised, 
		order = 10, method = "I", zero.policy = TRUE, style="W")
)
```

Here, Moran’s I is close to zero, and there is no pattern in the autocorrelations (i.e. no consistent upward or downward pattern as you travel across the x-axis). 

You can test for significance of Moran's I using Monte Carlo simulation. The function will return the distribution of Moran’s I values we could expect to get under the null hypothesis that proportion_abscised is randomly distributed across the traps. We then compare the observed Moran’s I value to this distribution. 

```{r, warning=FALSE}

# add spatial weights
lw <- spdep::nb2listw(nn, style="W", zero.policy = TRUE) 

# permutation test for Moran's I
MI  <-  spdep::moran.mc(dat$proportion_abscised, lw, nsim=599, zero.policy = TRUE) 
MI
plot(MI) 
```

In the plot, the observed Moran's I (vertical line) is close to the simulated distribution and we have a fairly large p-value. This suggests there is no spatial autocorrelation.

We can also do a moran scatterplot.

```{r, warning=FALSE}
spdep::moran.plot(dat$proportion_abscised, lw)
```

This shows proportion_abscised against its spatially lagged values. There's a line showing the linear relationship between the data and the lag and the dashed vertical lines mark Moran's I. Traps which have a strong effect on the linear trend have been labelled.

## Semivariogram

A semivariogram is another kind of graphical representation of spatial autocorrelation. Here, the x axis represents the distance between traps and each point represents a pair of observations. The distance at which the semivariogram stops increasing and flattens out is the range. Traps which are closer together than this distance are spatially autocorrelated.

```{r, warning=FALSE}
plot(
	gstat::variogram(proportion_abscised ~ 1, data = dat, 
		width = 5, cutoff = 200) 
)
```

Looking at this, I'd say the range was 15 meters. But the data doesn't look like it shows much autocorrelation - the y axis is quite narrow.

You can also visualise it as a map, I think the colour scale represents proportion_abscised.

```{r, warning=FALSE}
plot(
	gstat::variogram(proportion_abscised ~ 1, data = dat, 
		map = TRUE, width = 5, cutoff = 200)
)
```

So how do I get an idea of spatial autocorrelation for the whole dataset? All the work I did above was to do with a single species in a single year. Let's write some functions.

```{r, warning=FALSE}
# I have to rewrite the variogram function beacuse the data isn't the first argument
my_variogram <- function(data) {
	gstat::variogram(data = data, proportion_abscised ~ 1, width=5, cutoff = 100)
}

make_variogram <- function(data, species) {
	dplyr::filter(data, sp == species) %>%
	sf::st_as_sf(coords = c("X", "Y")) -> df_sf
	split(x = df_sf, f = df_sf$year, drop = TRUE) -> dfs
	purrr::map(dfs, .f = my_variogram) -> vgrams
	dplyr::bind_rows(vgrams, .id = "year")
}

# create an indexed sp list of 4 sp
sp_list <- list("tri2tu"= "tri2tu", "jac1co" ="jac1co", "alsebl"="alsebl", "faraoc"="faraoc")

# run the function
map_dfr(.x = sp_list, .f = make_variogram, .id = "sp", data = trapConnect) -> output

# try plotting
ggplot(output, aes(x = dist, y = gamma)) +
	geom_point() +
	facet_wrap("sp", ncol = 2) +
	scale_x_continuous(minor_breaks= seq(0, 100, 5))

# coloured by year
ggplot(output, aes(x = dist, y = gamma)) +
	geom_path(aes(colour = year))+
	facet_wrap("sp", ncol=2) +
	scale_x_continuous(minor_breaks= seq(0, 100, 5))
```

Looking at these plots, I think we can say that there isn't any spatial autocorrelation, or if there is, it is only in effect over very small distances. There is no real increase and or flattening out of semivariance, but this isn't a very nice way of displaying it. Is there some simple value or plot I can make that we can just stick in the supplementary?
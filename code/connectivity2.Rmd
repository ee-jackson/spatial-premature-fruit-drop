---
title: "Connectivity"
author: "Eleanor Jackson"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  html_document:
    theme: lumen
    highlight: pygments
---

I'm going to try two different measures of connectivity, __Hanskiâ€™s Connectivity Index (CI)__ [(Hanski 1994)](https://www.jstor.org/stable/5591) and the __Conspecific neighbourhood fecundity index (NFI)__ [(Jones & Comita 2008)](https://royalsocietypublishing.org/doi/10.1098/rspb.2008.0894#d3e405). 

They differ in that Hanski's CI includes an exponential function, meaning that it doesn't weigh short distances as heavily. (e.g if a tree was right next to a trap you'd risk getting an inf value for NFI). CI also needs the average dispersal distance to scale your distances, which I'm just going to take as 50m for now.

I had to alter these equations a little. NFI uses the yearly mean total fruit set per tree to weight individuals - we don't have this, so I just used DBH, which assumes that larger individuals produce more fruit [(see here)](https://www.jstor.org/stable/2389015).

__Hanski's Connectivity Index__\

$CI = \sum exp(-\, \alpha \, dist_{ji}) A_j$ \

__Conspecific neighbourhood fecundity index__\

$NFI = \sum \frac {A_j}{dist_{ij}}$ \

_j_ = conspecific tree within a 100m radius of the trap\
_dist_ = distance between trap i and tree j\
$\alpha$ = 1/ avg. dispersal ability\
_A_ = DBH of tree j\

```{r, warning=FALSE, message=FALSE}
rm(list = ls())
library("tidyverse"); theme_set(theme_bw(base_size=10))
library("rdist")
library("parallel")
library("lme4")
library("ggeffects")
library("knitr")
opts_chunk$set(tidy.opts=list(width.cutoff=50), tidy=FALSE, cache.lazy = FALSE,cache = TRUE)
```
## Read in and compile the data


```{r, warning=FALSE, results="hide"}
# find and load all bci files in one go
file_names <- as.list(dir(
	path="/Users/eleanorjackson/OneDrive - University of Reading/SpatialPatterns/data/bci.tree", 
	pattern="bci.tree*"))

file_paths <- paste("../data/bci.tree/", file_names, sep="")
lapply(file_paths, load, environment())

# read in other data
load("../data/bci.spptable.rdata")
trapDat <- read.csv("../output/tables/proportionAbscisedPerTrap.csv") 
RST <- read.csv("../output/tables/R50.csv") # reproductive size threshold

# bind all the bci datasets together
bci.bind <- bind_rows(mget(ls(pattern="bci.tree*")), .id='df')
rm(list = ls(pattern='bci.tree*')) # remove the separate bci files

# add column for survey year
bci.bind %>%
    mutate(year = case_when(df == "bci.tree8" ~ "2015",
                            df == "bci.tree7" ~ "2010",
                            df == "bci.tree6" ~ "2005",
                        	df == "bci.tree5" ~ "2000",
                        	df == "bci.tree4" ~ "1995",
                        	df == "bci.tree3" ~ "1990",
                        	df == "bci.tree2" ~ "1985",
                        	df == "bci.tree1" ~ "1982")) -> bci.tree

# join bci with sp data and reproductive size threshold data
bci <- left_join(bci.tree, bci.spptable, by = "sp")
bci <- left_join(bci, RST, by = "sp")

# add id tags to id values so they don't just look like numbers
trapDat$trap <- paste("trap", trapDat$trap, sep="_")
bci$treeID <- paste("tree", bci$treeID, sep="_")

# will need year to be a character when we merge later
trapDat$year <- as.character(trapDat$year) 

```
## Calculate euclidean distances
We will create a pairwise matrix with the rdist package to calculate the distance between each tree/trap combo. 

```{r, warning=FALSE}

calculate_dist <- function (species, yr) {
	# subset tree data
	bd <- dplyr::filter(bci, (bci[,"status"]=="A") & (bci[,"sp"]==species) & 
		(bci[,"dbh"]>bci[,"R50"]) & (bci[,"year"]==yr))

	# subset trap data
	td <- dplyr::filter(trapDat, (trapDat[,"year"]==yr) & 
		(trapDat[,"SP6"]==species))

	# create distance matrix using x and y co-ordinates
	dists <- cdist(bd[,c("gx", "gy")], td[,c("X", "Y")], metric="euclidean")
	dists.df <- as.data.frame(dists)

	# label col and row names with trap and tree IDs
	rownames(dists.df) <- unlist(bd$treeID)
	colnames(dists.df) <- unlist(td$trap)

	# bind with the bci data
	cbind(bd, dists.df)
}

# create lists of sp and year to pass to function
#sp.list <- unique(bci[["sp"]])
#year.list <- unique(bci[["year"]])

# apply function to all pairwise combinations of year and species
#all.dists <- outer(sp.list, year.list, FUN = Vectorize(calculate_dist))
#bci.dists <- bind_rows(all.dists, .id = "df")

#for now just apply function to one year and one species
bci.dists <- calculate_dist("cordbi", "2015")

```
## Conspecific neighbourhood fecundity index
Lets start by calculating NFI.
```{r, warning=FALSE}
# function to calculate NFI
calculate_NFI <- function (trap) {
	dplyr::filter(bci.dists, bci.dists[,trap] <= 100) %>% # subset to only trees within a 100m radius of the trap
	group_by(treeID, year, sp) %>% 
	mutate(a = dbh / eval(parse(text=trap))) %>% # divide dbh by dist
	ungroup() %>%
	dplyr::select(year, sp, trap, a) %>%
	group_by(year, sp) %>%
	summarise(trap = paste(trap), NFI = sum(a)) %>% # sum over all trees to = 1 value per trap
	ungroup()
}

# create list of trap IDs to pass through the function
trap.list <- colnames(select(bci.dists, matches("trap_")))

# apply function to each trap and parallelize
numCores <- detectCores()
NFIdat <- mclapply(trap.list, calculate_NFI, mc.cores = numCores)

# bind output into one dataframe
NFIdat.b <- bind_rows(NFIdat)

# merge with trap data
trapConnect <- left_join(NFIdat.b, trapDat,  
	by = c("trap", "year", "sp" = "SP6"))

head(NFIdat.b) #take a look at NFI values
```
## Hanski's Connectivity index
Now on to CI using the same format.

```{r, warning=FALSE}
# function to calculate CI
calculate_CI <- function (trap) {
	dplyr::filter(bci.dists, bci.dists[,trap] <= 100) %>% 
	group_by(treeID, year, sp) %>% 
	mutate(a = dbh * exp( (-1/50) * eval(parse(text=trap)) ) ) %>% 
	ungroup() %>%
	dplyr::select(year, sp, trap, a) %>%
	group_by(year, sp) %>%
	summarise(trap = paste(trap), CI = sum(a))
}


CIdat <- mclapply(trap.list, calculate_CI, mc.cores = numCores)
CIdat.b <- bind_rows(CIdat)
trapConnect <- left_join(trapConnect, CIdat.b, by = c("trap", "year", "sp"))

head(CIdat.b) #take a look at CI values
```

## Build and run some models

```{r, warning=FALSE}

m1 <- glm(cbind(abscised_seeds, viable_seeds) ~ 
	NFI, family = binomial(logit), 
	data = trapConnect)

m2 <- glm(cbind(abscised_seeds, viable_seeds) ~ 
	CI, family = binomial(logit), 
	data = trapConnect)

# compare
models <- list(m1, m2)
purrr::map_dfr(models, broom::tidy, 
							conf.int = TRUE, .id = "model")

```
The model outputs look pretty similar, which is reassuring!  
Lets see if NFI and CI actually correlate.\

```{r, warning=FALSE, fig_width=8, fig_height=6}
ggplot(trapConnect) +
	geom_point(aes(x= CI, y= NFI))
```
\
They do! But less so towards larger values which makes sense when you look at the equations. 
Lets see what our models look like when plotted. I'm going to scale the size of the points with the sum of parts found in the trap.\

```{r, warning=FALSE, message=FALSE, fig_width=8, fig_height=6}

output.NFI <- ggpredict(m1, terms = "NFI")
output.CI <- ggpredict(m2, terms = "CI")

ggplot() +
        geom_point(data= trapConnect, aes(x = NFI, 
        					y = proportion_abscised, size=sum_parts), alpha= 0.5) +
        geom_line(data= output.NFI, aes(x = x, y = predicted), 
        					colour= "blue") +
        geom_ribbon(data= output.NFI, aes(x = x, ymin = conf.low, ymax = conf.high), alpha= 0.1, fill="blue") +
        xlab("NFI") +
        ylab("Proportion of seeds abscised") -> p1

ggplot() +
        geom_point(data= trapConnect, aes(x = CI, 
        					y = proportion_abscised, size=sum_parts),  alpha= 0.5) +
        geom_line(data= output.CI, aes(x = x, y = predicted), 
        					colour= "blue") +
        geom_ribbon(data= output.CI, aes(x = x, ymin = conf.low, ymax = conf.high), alpha= 0.1, fill="blue") +
        xlab("CI") +
        ylab("Proportion of seeds abscised") -> p2

p1
p2
```
\
Looks ok and trend is as predicted. Hard to tell, but traps with lower 'sum_parts' do seem to be weighted less - probably because of our cbind() data structure. 
Next steps are to include something to correct for edge effects and extend to multiple species and years.\
